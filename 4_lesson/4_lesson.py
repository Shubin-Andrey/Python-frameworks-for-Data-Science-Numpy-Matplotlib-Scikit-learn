#!/usr/bin/env python
# coding: utf-8

# Задание 1
# Загрузите модуль pyplot библиотеки matplotlib с псевдонимом plt, а также библиотеку numpy с псевдонимом np.
# Примените магическую функцию %matplotlib inline для отображения графиков в Jupyter Notebook и настройки конфигурации ноутбука со значением 'svg' для более четкого отображения графиков.
# Создайте список под названием x с числами 1, 2, 3, 4, 5, 6, 7 и список y с числами 3.5, 3.8, 4.2, 4.5, 5, 5.5, 7.
# С помощью функции plot постройте график, соединяющий линиями точки с горизонтальными координатами из списка x и вертикальными - из списка y.
# Затем в следующей ячейке постройте диаграмму рассеяния (другие названия - диаграмма разброса, scatter plot).
# 

# In[2]:


import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'svg'")


# In[3]:


x = [1, 2, 3, 4, 5, 6, 7]
y = [3.5, 3.8, 4.2, 4.5, 5, 5.5, 7]


# In[6]:


plt.plot(x, y)
plt.show() 


# In[7]:


plt.scatter(x, y)
plt.show() 


# Задание 2
# С помощью функции linspace из библиотеки Numpy создайте массив t из 51 числа от 0 до 10 включительно.
# Создайте массив Numpy под названием f, содержащий косинусы элементов массива t.
# Постройте линейную диаграмму, используя массив t для координат по горизонтали,а массив f - для координат по вертикали. Линия графика должна быть зеленого цвета.
# Выведите название диаграммы - 'График f(t)'. Также добавьте названия для горизонтальной оси - 'Значения t' и для вертикальной - 'Значения f'.
# Ограничьте график по оси x значениями 0.5 и 9.5, а по оси y - значениями -2.5 и 2.5.
# 

# In[8]:


t = np.linspace(0, 10, 51)
f = np.cos(t)
f


# In[9]:


plt.plot(t, f , color="green")
plt.title('График f(t)')
plt.xlabel('Значения t')
plt.ylabel('Значения f')
plt.axis([0.5, 9.5, -2.5, 2.5])
plt.show() 


# *Задание 3
# С помощью функции linspace библиотеки Numpy создайте массив x из 51 числа от -3 до 3 включительно.
# Создайте массивы y1, y2, y3, y4 по следующим формулам:
# y1 = x**2
# y2 = 2 * x + 0.5
# y3 = -3 * x - 1.5
# y4 = sin(x)
# Используя функцию subplots модуля matplotlib.pyplot, создайте объект matplotlib.figure.Figure с названием fig и массив объектов Axes под названием ax,причем так, чтобы у вас было 4 отдельных графика в сетке, состоящей из двух строк и двух столбцов. В каждом графике массив x используется для координат по горизонтали.В левом верхнем графике для координат по вертикали используйте y1,в правом верхнем - y2, в левом нижнем - y3, в правом нижнем - y4.Дайте название графикам: 'График y1', 'График y2' и т.д.
# Для графика в левом верхнем углу установите границы по оси x от -5 до 5.
# Установите размеры фигуры 8 дюймов по горизонтали и 6 дюймов по вертикали.
# Вертикальные и горизонтальные зазоры между графиками должны составлять 0.3.
# 

# In[10]:


x = np.linspace(-3, 3, 51)


# In[11]:


y1 = x**2
y2 = 2 * x + 0.5
y3 = -3 * x - 1.5
y4 = np.sin(x)


# In[12]:


fig, ax = plt.subplots(nrows=2, ncols=2, sharex=False, sharey=False)
ax1, ax2, ax3, ax4 = ax.flatten()

fig.set_size_inches(8, 6)
fig.subplots_adjust(wspace=0.3, hspace=0.3)

ax1.plot(x, y1)
ax1.set_title('График y1')
ax1.set_xlim([-5, 5])

ax2.plot(x, y2)
ax2.set_title('График y2')

ax3.plot(x, y3)
ax3.set_title('График y3')

ax4.plot(x, y4)
ax4.set_title('График y4')


# *Задание 4
# В этом задании мы будем работать с датасетом, в котором приведены данные по мошенничеству с кредитными данными: Credit Card Fraud Detection (информация об авторах: Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015).
# Ознакомьтесь с описанием и скачайте датасет creditcard.csv с сайта Kaggle.com по ссылке:
# Credit Card Fraud Detection
# Данный датасет является примером несбалансированных данных, так как мошеннические операции с картами встречаются реже обычных.
# Импортируйте библиотеку Pandas, а также используйте для графиков стиль “fivethirtyeight”.
# Посчитайте с помощью метода value_counts количество наблюдений для каждого значения целевой переменной Class и примените к полученным данным метод plot, чтобы построить столбчатую диаграмму. Затем постройте такую же диаграмму, используя логарифмический масштаб.
# На следующем графике постройте две гистограммы по значениям признака V1 - одну для мошеннических транзакций (Class равен 1) и другую - для обычных (Class равен 0). Подберите значение аргумента density так, чтобы по вертикали графика было расположено не число наблюдений, а плотность распределения. Число бинов должно равняться 20 для обеих гистограмм, а коэффициент alpha сделайте равным 0.5, чтобы гистограммы были полупрозрачными и не загораживали друг друга. Создайте легенду с двумя значениями: “Class 0” и “Class 1”. Гистограмма обычных транзакций должна быть серого цвета, а мошеннических - красного. Горизонтальной оси дайте название “V1”.
# 

# In[13]:


creditcard = pd.read_csv("D:\creditcard.csv")
creditcard


# In[14]:


creditcard[creditcard['Class'] > 0].head()


# In[15]:


val_count_class = creditcard.Class.value_counts(normalize=False).reset_index(drop='True')
val_count_class


# In[16]:


plt.style.use('fivethirtyeight')
val_count_class.plot()
plt.show() 


# In[17]:


val_count_class.plot(kind='bar')
plt.yscale(value="log")
plt.show() 


# Ну очень мало значений не равных 0

# In[30]:


card_V1_cl0 = creditcard.loc[creditcard['Class'] == 0, 'V1']


# In[29]:


card_V1_cl1 = creditcard.loc[creditcard['Class'] == 1, 'V1']


# In[40]:


#df["Test_1"].plot.kde(bw_method=0.5) 
fig, ax = plt.subplots(nrows=1, ncols=2, sharex=False, sharey=False)
ax1, ax2 = ax.flatten()
ax1.hist(card_V1_cl0, orientation="horizontal", bins=20, color="lightgrey", ec="white")
ax1.set_title('class0')

ax2.hist(card_V1_cl1, orientation="horizontal", bins=20, color="red", ec="white")
ax2.set_title('class1')


# In[42]:


plt.hist(card_V1_cl0, orientation="horizontal", bins=20, color="lightgrey", ec="white", alpha = 0.5)
plt.hist(card_V1_cl1, orientation="horizontal", bins=20, color="red", ec="white", alpha = 0.5)
plt.xlabel('V1')
plt.legend(labels=["Class 0", "Class 1"])
plt.xscale(value="log")
plt.show() 


# **Задание на повторение материала
# 

# 1 Создать одномерный массив Numpy под названием a из 12 последовательных целых чисел чисел от 12 до 24 невключительно

# In[45]:


a = np.linspace(12, 23, 12)
a


# 2 Создать 5 двумерных массивов разной формы из массива a. Не использовать в аргументах метода reshape число -1.

# In[46]:


a1 = a.reshape(3, 4)
a1


# In[47]:


a2 = a.reshape(2, 6)
a2


# In[49]:


a3 = a.reshape(4, 3)
a3


# In[50]:


a4 = a.reshape(6, 2)
a4


# In[51]:


a5 = a.reshape(12, 1)
a5


# 3 Создать 5 двумерных массивов разной формы из массива a. Использовать в аргументах метода reshape число -1 (в трех примерах - для обозначения числа столбцов, в двух - для строк).

# In[52]:


a1 = a.reshape(2, -1)
a1


# In[53]:


a2 = a.reshape(3, -1)
a2


# In[54]:


a3 = a.reshape(4, -1)
a3


# In[55]:


a4 = a.reshape(-1, 2)
a4


# In[56]:


a5 = a.reshape(-1, 1)
a5


# 4 Можно ли массив Numpy, состоящий из одного столбца и 12 строк, назвать одномерным?
# 

# In[59]:


a5.shape


# In[61]:


type(a5)


# нет, нельзя. Одномерный массив — это фиксированное количество элементов одного и того же типа, объединенных одним именем, где каждый элемент имеет свой номер. Обращение к элементам массива осуществляется с помощью указания имени массива и номеров элементов. Тут у нас список списков и для обращения к элементу необходимо использовать 2 индекса

# In[62]:


a5[2]


# In[63]:


a5[2][0]


# 5 Создать массив из 3 строк и 4 столбцов, состоящий из случайных чисел с плавающей запятой из нормального распределения со средним, равным 0 и среднеквадратичным отклонением, равным 1.0. Получить из этого массива одномерный массив с таким же атрибутом size, как и исходный массив.

# In[64]:


b = np.random.randn(3, 4)
b


# In[65]:


b.size


# In[77]:


b1 = b.flatten()
b1


# In[78]:


b1.size


# 6 Создать массив a, состоящий из целых чисел, убывающих от 20 до 0 невключительно с интервалом 2.
# 

# In[80]:


a = np.arange(20, 0, -2)
a


# 7 Создать массив b, состоящий из 1 строки и 10 столбцов: целых чисел, убывающих от 20 до 1 невключительно с интервалом 2. В чем разница между массивами a и b?

# In[89]:


b = np.arange(20, 1, -2).reshape(1, 10)
b


# In[86]:


b[1]


# In[87]:


b[0]


# In[90]:


a.shape


# In[91]:


b.shape


# а одномерный массив , а b двумерный

# 8 Вертикально соединить массивы a и b. a - двумерный массив из нулей, число строк которого больше 1 и на 1 меньше, чем число строк двумерного массива b, состоящего из единиц. Итоговый массив v должен иметь атрибут size, равный 10.

# In[92]:


a = np.zeros((3, 4))
b = np.ones((4, 4))


# In[94]:


c = np.vstack((a, b))
c


# 9 Создать одномерный массив а, состоящий из последовательности целых чисел от 0 до 12. Поменять форму этого массива, чтобы получилась матрица A (двумерный массив Numpy), состоящая из 4 строк и 3 столбцов. Получить матрицу At путем транспонирования матрицы A. Получить матрицу B, умножив матрицу A на матрицу At с помощью матричного умножения. Какой размер имеет матрица B? Получится ли вычислить обратную матрицу для матрицы B и почему?
# 

# In[96]:


a = np.arange(0, 12)
a


# In[99]:


A = a.reshape(4, 3)
A


# In[100]:


At = A.T
At


# In[101]:


B = A.dot(At)
B


# In[102]:


B.shape


# In[103]:


d = np.linalg.det(B)
d


# In[104]:


B_inv = np.linalg.inv(B)


# Обратную матрицу можно посчитать только для матрицы,
# определитель которой не равен 0.
# Если определитель матрицы равен d, то определитель обратной матрицы всегда будет равен 1/d. Именно поэтому
# матрицы с определителем, равным 0, обращать нельзя.

# 10 Инициализируйте генератор случайных числе с помощью объекта seed, равного 42.
# 

# In[109]:


import random 
random.seed(42)
a = [random.randint(0, 10) for _ in range(10)]
a


# 11 Создайте одномерный массив c, составленный из последовательности 16-ти случайных равномерно распределенных целых чисел от 0 до 16 невключительно. 
# 

# In[110]:


c = [random.randint(0, 16) for _ in range(16)]
c


# 12 Поменяйте его форму так, чтобы получилась квадратная матрица C. Получите матрицу D, поэлементно прибавив матрицу B из предыдущего вопроса к матрице C, умноженной на 10. Вычислите определитель, ранг и обратную матрицу D_inv для D.
# 

# In[111]:


C = np.array(c).reshape(4, -1)
C


# In[112]:


D = C*10 + B
D


# In[113]:


d = np.linalg.det(D)
d


# In[114]:


r = np.linalg.matrix_rank(D)
r


# In[115]:


D_inv = np.linalg.inv(D)
D_inv


# In[118]:


test = D.dot(D_inv)
test.round()


# 12 Приравняйте к нулю отрицательные числа в матрице D_inv, а положительные - к единице. Убедитесь, что в матрице D_inv остались только нули и единицы. С помощью функции numpy.where, используя матрицу D_inv в качестве маски, а матрицы B и C - в качестве источников данных, получите матрицу E размером 4x4.  Элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 1, должны быть равны соответствующему элементу матрицы B, а элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 0, должны быть равны соответствующему элементу матрицы C.
# 

# In[120]:


for i in range(len(D_inv)):
    for j in range(len (D_inv[i])):
        if D_inv[i][j] > 0:
            D_inv[i][j] = 1
        elif D_inv[i][j] < 0:
            D_inv[i][j] = 0
D_inv            


# In[128]:


E = np.where(D_inv == 1, B, C)
E


# In[ ]:




